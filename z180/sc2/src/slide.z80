INCLUDE "tms.inc"
INCLUDE "tms_constants.inc"
INCLUDE "stdio.inc"
INCLUDE "nouveau.inc"
INCLUDE "macros.inc"

MACRO print addr
        ld      c,C_WRITESTR
        ld      de,addr
        call    BDOS
ENDM

MACRO newline
        ld      c,C_WRITESTR
        ld      de,eol
        call    BDOS
ENDM

BDOS:           equ 5

C_WRITESTR:     equ 9   ; C=9, DE=address of $ terminated string
F_OPEN:         equ 15  ; C=0xF, DE=FCB Address, Errors returned in BA, HL
F_CLOSE:        equ 16  ; C=0x10, DE=FCB Address, Errors in BA, HL
F_SFIRST:       equ 17
F_SNEXT:        equ 18
F_READ:         equ 20  ; C=0x14, DE=FCB Address, Errros in BA, HL
F_DMAOFF:       equ 26  ; C=0x1A, DE=Address

FCB:            equ 0x5C
DEF_BUF:        equ 0x80

BUFFER:         equ 0x1000
LISTBUF:        equ 0x5000

; BEGIN
        org     0x100
        ld      sp,stack
main:
        vb_loop:
        in      a,(io_tmslatch)
        or      0x80
        jr      z,vb_loop

        call    tms_init_g2

        ld      c,tms_black
        call    tms_set_backdrop_color

        ld      hl,LISTBUF
        ld      (cur_list_buf_ptr),hl

        call    find_first
        call    copy_name_to_list_buf
loop:
        call    find_next
        cp      0xFF
        jp      z,start_show
        call    copy_name_to_list_buf
        cp      0xFF            ; only allow 256 images
        jr      nz,loop

start_show:
        ld      hl,LISTBUF
        ld      (cur_list_buf_ptr),hl
show_loop:
        call    open
        call    read_file
        call    close
        call    vdp_write
        dec8    file_count
        or      a
        jp      z,exit
        call    delay

        ld      hl,(cur_list_buf_ptr)
        ld      bc,12
        add     hl,bc
        ld      (cur_list_buf_ptr),hl
        jp      show_loop

        ; DE must contain location of buffer
setdma:
        ld      c,F_DMAOFF
        call    BDOS
        ret

        ; sets new_fcb_ptr on exit
find_first:
        ld      de,DEF_BUF
        call    setdma

        call    initfcb

        ld      c,F_SFIRST
        ld      de,FCB
        call    BDOS
        cp      0xff
        jp      nz,find_cont
        print   find_err
        jp      0

find_next:
        ld      de,DEF_BUF
        call    setdma
        ld      c,F_SNEXT
        call    BDOS
        cp      0xff
        jp      nz,find_cont
        ret

find_cont:
        ld      h,0
        ld      l,a
        add     hl,hl
        add     hl,hl
        add     hl,hl
        add     hl,hl
        add     hl,hl
        ld      bc,DEF_BUF
        add     hl,bc
        ld      (new_fcb_ptr),hl
        ret

copy_name_to_list_buf:
        ld      hl,(new_fcb_ptr)
        ld      de,(cur_list_buf_ptr)
        ld      bc,12
        ldir

        ld      hl,(cur_list_buf_ptr)
        ld      bc,12
        add     hl,bc
        ld      (cur_list_buf_ptr),hl
        inc8    file_count
        ret

open:
        ;print filename
        ld      hl,(cur_list_buf_ptr)
        inc     hl
        ld      de,text_buf
        ld      bc,11
        ldir

        ld      de,text_buf
        ld      c,C_WRITESTR
        call    BDOS

        ; prep FCB for open - first copy name from list pointer
        ; fill rest of FCB with zeros
        ld      hl,FCB+12
        ld      b,36
        xor     a
open_l1:
        ld      (hl),a
        inc     hl
        djnz    open_l1

        ; copy filename over
        ld      hl,(cur_list_buf_ptr)
        inc     hl
        ld      de,FCB+1
        ld      bc,11
        ldir
IF 0
        call    debug_fcb
ENDIF
        ld      c,F_OPEN
        ld      de,FCB
        call    BDOS
        cp      0xFF
        jr      z,open_is_err
        ret
open_is_err:
        print   open_err
        jp      exit

close:
        ld      c,F_CLOSE
        ld      de,(cur_list_buf_ptr)
        call    BDOS
        ret

initfcb:
        ld      hl,search
        ld      de,FCB+1
        ld      bc,11
        ldir


        ; fill rest of FCB with zeros
        xor     a
        ; drive
        ld      hl,FCB
        ld      (hl),a
        ; everything else besides filename
        ld      hl,FCB+12
        ld      b,35-12
initfcb_l1:
        ld      (hl),a
        inc     hl
        djnz    initfcb_l1
        ret

read_file:
        ld      de,BUFFER
        ld      c,F_DMAOFF
        call    BDOS

        ld      de,BUFFER
        push    de
read_file_lp:
        ld      c,F_READ
        ld      de,FCB
        call    BDOS
        ; was it the end of file
        or      a
        jp      nz,eofile
        ; get DE from the stack
        pop     de
        ; add 128
        add     de,0x80
        ; save back to stack
        push    de
        ; set new DMA
        ld      c,F_DMAOFF
        call    BDOS
        ; loop
        jp      read_file_lp
eofile:
        pop     de              ; stack is all good now
        ret

vdp_write:
        ld      de,0
        ld      hl,BUFFER + 7
        ; HL now is at start of data
        ld      bc,0x3800

        in      a,(io_tmslatch)                    ; read the status register to reset the reg fsm
        call    tms_set_write_address

        ld      d,b
        ld      e,c
        ld      c,io_tmsdata

        ld      a,d
        or      a
        jr      z,wr_resid
        ld      b,0             ; 256 bytes
wr_256:
        otir
        dec     d
        jr      nz,wr_256

wr_resid:
        ; is there any residual ?
        ld      a,e
        or      a
        jr      nz,wr_resid_cont
        ret
wr_resid_cont:
        ld      b,e
        otir
        ret

delay:
        call    get_char
        cp      0x1b
        jp      z,exit
        ld      b,180
        call    tms_delay
        ret

exit:
        jp      0
IF 0

debug_fcb:
        ld      hl,FCB
        ld      b,36
debug_fcb_lp:
        ld      a,(hl)
        push    bc
        push    hl
        call    hexdump_a
        pop     hl
        pop     bc
        inc     hl
        djnz    debug_fcb_lp
        newline
        ret

hexdump_a:
        push    af
        srl     a
        srl     a
        srl     a
        srl     a
        call    hexdump_nib
        pop     af
        push    af
        and     0x0f
        call    hexdump_nib
        ld      a,':'
        call    puts
        pop     af
        ret

hexdump_nib:
        add     '0'
        cp      '9'+1
        jp      m,hexdump_num
        add     'A'-'9'-1
hexdump_num:
        jp      puts
ENDIF

;==============================================================================
;       VARIABLES
;==============================================================================
search: db "????????SC2"
open_err: db "OPEN FILE ERROR",10,13,"$"
find_err: db "FIND FILE ERROR",10,13,"$"
new_fcb_ptr: dw 0
cur_list_buf_ptr: dw 0
file_count:     db 0
text_buf:       ds 11,0
eol:            db 10,13,"$"

;==============================================================================
;       STACK
;==============================================================================
        ds      1024
stack:  equ     $
